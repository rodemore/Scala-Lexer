Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CLASS
    COMMA
    DECREMENT
    DEF
    DOT
    ELSE
    EQ
    EQUALS
    FOR
    HEAD
    INCREMENT
    ISEMPTY
    LBRACK
    LENGTH
    LIST
    LPAREN
    MOD
    NEW
    OBJECT
    PRINTLN
    PRODUCTITERATOR
    RBRACK
    RETURN
    REVERSE
    RPAREN
    SEMICOLON
    SWAP
    TAIL
    THIS
    TOSTRING
    VAL
    WHILE
    unit

Grammar

Rule 0     S' -> declararVariable
Rule 1     declararVariable -> VAR ID COLON tipoValue
Rule 2     declararVariable -> VAR ID COLON tipo
Rule 3     declararVariable -> VAR ID EQUAL value
Rule 4     declararVariable -> VAR ID EQUAL expression
Rule 5     value -> string
Rule 6     value -> booleano
Rule 7     tipo -> INT
Rule 8     tipo -> DOUBLE
Rule 9     tipo -> BOOL
Rule 10    tipo -> STRING_TYPE
Rule 11    tipoValue -> STRING_TYPE EQUAL string
Rule 12    tipoValue -> BOOL EQUAL booleano
Rule 13    tipoValue -> INT EQUAL int
Rule 14    tipoValue -> DOUBLE EQUAL double
Rule 15    cuerpo -> expression
Rule 16    cuerpo -> sentencia
Rule 17    expression -> expression PLUS term
Rule 18    expression -> expression MINUS term
Rule 19    expression -> term
Rule 20    term -> term TIMES factor
Rule 21    term -> term DIVIDE factor
Rule 22    term -> factor
Rule 23    sentencia -> IF factor comparacion factor LBRACE cuerpo RBRACE
Rule 24    comparacion -> GT
Rule 25    comparacion -> GE
Rule 26    comparacion -> LT
Rule 27    comparacion -> LE
Rule 28    factor -> INT_NUMBER
Rule 29    factor -> DOUBLE_NUMBER
Rule 30    booleano -> TRUE
Rule 31    booleano -> FALSE
Rule 32    string -> STRING
Rule 33    double -> DOUBLE_NUMBER
Rule 34    int -> INT_NUMBER

Terminals, with rules where they appear

ARRAY                : 
BOOL                 : 9 12
CLASS                : 
COLON                : 1 2
COMMA                : 
DECREMENT            : 
DEF                  : 
DIVIDE               : 21
DOT                  : 
DOUBLE               : 8 14
DOUBLE_NUMBER        : 29 33
ELSE                 : 
EQ                   : 
EQUAL                : 3 4 11 12 13 14
EQUALS               : 
FALSE                : 31
FOR                  : 
GE                   : 25
GT                   : 24
HEAD                 : 
ID                   : 1 2 3 4
IF                   : 23
INCREMENT            : 
INT                  : 7 13
INT_NUMBER           : 28 34
ISEMPTY              : 
LBRACE               : 23
LBRACK               : 
LE                   : 27
LENGTH               : 
LIST                 : 
LPAREN               : 
LT                   : 26
MINUS                : 18
MOD                  : 
NEW                  : 
OBJECT               : 
PLUS                 : 17
PRINTLN              : 
PRODUCTITERATOR      : 
RBRACE               : 23
RBRACK               : 
RETURN               : 
REVERSE              : 
RPAREN               : 
SEMICOLON            : 
STRING               : 32
STRING_TYPE          : 10 11
SWAP                 : 
TAIL                 : 
THIS                 : 
TIMES                : 20
TOSTRING             : 
TRUE                 : 30
VAL                  : 
VAR                  : 1 2 3 4
WHILE                : 
error                : 
unit                 : 

Nonterminals, with rules where they appear

booleano             : 6 12
comparacion          : 23
cuerpo               : 23
declararVariable     : 0
double               : 14
expression           : 4 15 17 18
factor               : 20 21 22 23 23
int                  : 13
sentencia            : 16
string               : 5 11
term                 : 17 18 19 20 21
tipo                 : 2
tipoValue            : 1
value                : 3

Parsing method: LALR

state 0

    (0) S' -> . declararVariable
    (1) declararVariable -> . VAR ID COLON tipoValue
    (2) declararVariable -> . VAR ID COLON tipo
    (3) declararVariable -> . VAR ID EQUAL value
    (4) declararVariable -> . VAR ID EQUAL expression

    VAR             shift and go to state 2

    declararVariable               shift and go to state 1

state 1

    (0) S' -> declararVariable .



state 2

    (1) declararVariable -> VAR . ID COLON tipoValue
    (2) declararVariable -> VAR . ID COLON tipo
    (3) declararVariable -> VAR . ID EQUAL value
    (4) declararVariable -> VAR . ID EQUAL expression

    ID              shift and go to state 3


state 3

    (1) declararVariable -> VAR ID . COLON tipoValue
    (2) declararVariable -> VAR ID . COLON tipo
    (3) declararVariable -> VAR ID . EQUAL value
    (4) declararVariable -> VAR ID . EQUAL expression

    COLON           shift and go to state 4
    EQUAL           shift and go to state 5


state 4

    (1) declararVariable -> VAR ID COLON . tipoValue
    (2) declararVariable -> VAR ID COLON . tipo
    (11) tipoValue -> . STRING_TYPE EQUAL string
    (12) tipoValue -> . BOOL EQUAL booleano
    (13) tipoValue -> . INT EQUAL int
    (14) tipoValue -> . DOUBLE EQUAL double
    (7) tipo -> . INT
    (8) tipo -> . DOUBLE
    (9) tipo -> . BOOL
    (10) tipo -> . STRING_TYPE

    STRING_TYPE     shift and go to state 8
    BOOL            shift and go to state 9
    INT             shift and go to state 10
    DOUBLE          shift and go to state 11

    tipoValue                      shift and go to state 6
    tipo                           shift and go to state 7

state 5

    (3) declararVariable -> VAR ID EQUAL . value
    (4) declararVariable -> VAR ID EQUAL . expression
    (5) value -> . string
    (6) value -> . booleano
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (32) string -> . STRING
    (30) booleano -> . TRUE
    (31) booleano -> . FALSE
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (28) factor -> . INT_NUMBER
    (29) factor -> . DOUBLE_NUMBER

    STRING          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    INT_NUMBER      shift and go to state 21
    DOUBLE_NUMBER   shift and go to state 22

    value                          shift and go to state 12
    expression                     shift and go to state 13
    string                         shift and go to state 14
    booleano                       shift and go to state 15
    term                           shift and go to state 16
    factor                         shift and go to state 20

state 6

    (1) declararVariable -> VAR ID COLON tipoValue .

    $end            reduce using rule 1 (declararVariable -> VAR ID COLON tipoValue .)


state 7

    (2) declararVariable -> VAR ID COLON tipo .

    $end            reduce using rule 2 (declararVariable -> VAR ID COLON tipo .)


state 8

    (11) tipoValue -> STRING_TYPE . EQUAL string
    (10) tipo -> STRING_TYPE .

    EQUAL           shift and go to state 23
    $end            reduce using rule 10 (tipo -> STRING_TYPE .)


state 9

    (12) tipoValue -> BOOL . EQUAL booleano
    (9) tipo -> BOOL .

    EQUAL           shift and go to state 24
    $end            reduce using rule 9 (tipo -> BOOL .)


state 10

    (13) tipoValue -> INT . EQUAL int
    (7) tipo -> INT .

    EQUAL           shift and go to state 25
    $end            reduce using rule 7 (tipo -> INT .)


state 11

    (14) tipoValue -> DOUBLE . EQUAL double
    (8) tipo -> DOUBLE .

    EQUAL           shift and go to state 26
    $end            reduce using rule 8 (tipo -> DOUBLE .)


state 12

    (3) declararVariable -> VAR ID EQUAL value .

    $end            reduce using rule 3 (declararVariable -> VAR ID EQUAL value .)


state 13

    (4) declararVariable -> VAR ID EQUAL expression .
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term

    $end            reduce using rule 4 (declararVariable -> VAR ID EQUAL expression .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 14

    (5) value -> string .

    $end            reduce using rule 5 (value -> string .)


state 15

    (6) value -> booleano .

    $end            reduce using rule 6 (value -> booleano .)


state 16

    (19) expression -> term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    PLUS            reduce using rule 19 (expression -> term .)
    MINUS           reduce using rule 19 (expression -> term .)
    $end            reduce using rule 19 (expression -> term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 17

    (32) string -> STRING .

    $end            reduce using rule 32 (string -> STRING .)


state 18

    (30) booleano -> TRUE .

    $end            reduce using rule 30 (booleano -> TRUE .)


state 19

    (31) booleano -> FALSE .

    $end            reduce using rule 31 (booleano -> FALSE .)


state 20

    (22) term -> factor .

    TIMES           reduce using rule 22 (term -> factor .)
    DIVIDE          reduce using rule 22 (term -> factor .)
    PLUS            reduce using rule 22 (term -> factor .)
    MINUS           reduce using rule 22 (term -> factor .)
    $end            reduce using rule 22 (term -> factor .)


state 21

    (28) factor -> INT_NUMBER .

    TIMES           reduce using rule 28 (factor -> INT_NUMBER .)
    DIVIDE          reduce using rule 28 (factor -> INT_NUMBER .)
    PLUS            reduce using rule 28 (factor -> INT_NUMBER .)
    MINUS           reduce using rule 28 (factor -> INT_NUMBER .)
    $end            reduce using rule 28 (factor -> INT_NUMBER .)


state 22

    (29) factor -> DOUBLE_NUMBER .

    TIMES           reduce using rule 29 (factor -> DOUBLE_NUMBER .)
    DIVIDE          reduce using rule 29 (factor -> DOUBLE_NUMBER .)
    PLUS            reduce using rule 29 (factor -> DOUBLE_NUMBER .)
    MINUS           reduce using rule 29 (factor -> DOUBLE_NUMBER .)
    $end            reduce using rule 29 (factor -> DOUBLE_NUMBER .)


state 23

    (11) tipoValue -> STRING_TYPE EQUAL . string
    (32) string -> . STRING

    STRING          shift and go to state 17

    string                         shift and go to state 31

state 24

    (12) tipoValue -> BOOL EQUAL . booleano
    (30) booleano -> . TRUE
    (31) booleano -> . FALSE

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    booleano                       shift and go to state 32

state 25

    (13) tipoValue -> INT EQUAL . int
    (34) int -> . INT_NUMBER

    INT_NUMBER      shift and go to state 34

    int                            shift and go to state 33

state 26

    (14) tipoValue -> DOUBLE EQUAL . double
    (33) double -> . DOUBLE_NUMBER

    DOUBLE_NUMBER   shift and go to state 36

    double                         shift and go to state 35

state 27

    (17) expression -> expression PLUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (28) factor -> . INT_NUMBER
    (29) factor -> . DOUBLE_NUMBER

    INT_NUMBER      shift and go to state 21
    DOUBLE_NUMBER   shift and go to state 22

    term                           shift and go to state 37
    factor                         shift and go to state 20

state 28

    (18) expression -> expression MINUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (28) factor -> . INT_NUMBER
    (29) factor -> . DOUBLE_NUMBER

    INT_NUMBER      shift and go to state 21
    DOUBLE_NUMBER   shift and go to state 22

    term                           shift and go to state 38
    factor                         shift and go to state 20

state 29

    (20) term -> term TIMES . factor
    (28) factor -> . INT_NUMBER
    (29) factor -> . DOUBLE_NUMBER

    INT_NUMBER      shift and go to state 21
    DOUBLE_NUMBER   shift and go to state 22

    factor                         shift and go to state 39

state 30

    (21) term -> term DIVIDE . factor
    (28) factor -> . INT_NUMBER
    (29) factor -> . DOUBLE_NUMBER

    INT_NUMBER      shift and go to state 21
    DOUBLE_NUMBER   shift and go to state 22

    factor                         shift and go to state 40

state 31

    (11) tipoValue -> STRING_TYPE EQUAL string .

    $end            reduce using rule 11 (tipoValue -> STRING_TYPE EQUAL string .)


state 32

    (12) tipoValue -> BOOL EQUAL booleano .

    $end            reduce using rule 12 (tipoValue -> BOOL EQUAL booleano .)


state 33

    (13) tipoValue -> INT EQUAL int .

    $end            reduce using rule 13 (tipoValue -> INT EQUAL int .)


state 34

    (34) int -> INT_NUMBER .

    $end            reduce using rule 34 (int -> INT_NUMBER .)


state 35

    (14) tipoValue -> DOUBLE EQUAL double .

    $end            reduce using rule 14 (tipoValue -> DOUBLE EQUAL double .)


state 36

    (33) double -> DOUBLE_NUMBER .

    $end            reduce using rule 33 (double -> DOUBLE_NUMBER .)


state 37

    (17) expression -> expression PLUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    PLUS            reduce using rule 17 (expression -> expression PLUS term .)
    MINUS           reduce using rule 17 (expression -> expression PLUS term .)
    $end            reduce using rule 17 (expression -> expression PLUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 38

    (18) expression -> expression MINUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    PLUS            reduce using rule 18 (expression -> expression MINUS term .)
    MINUS           reduce using rule 18 (expression -> expression MINUS term .)
    $end            reduce using rule 18 (expression -> expression MINUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 39

    (20) term -> term TIMES factor .

    TIMES           reduce using rule 20 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 20 (term -> term TIMES factor .)
    PLUS            reduce using rule 20 (term -> term TIMES factor .)
    MINUS           reduce using rule 20 (term -> term TIMES factor .)
    $end            reduce using rule 20 (term -> term TIMES factor .)


state 40

    (21) term -> term DIVIDE factor .

    TIMES           reduce using rule 21 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 21 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 21 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 21 (term -> term DIVIDE factor .)
    $end            reduce using rule 21 (term -> term DIVIDE factor .)

